'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.wrap = exports.unwrap = undefined;

var _http = require('http');

var _http2 = _interopRequireDefault(_http);

var _https = require('https');

var _https2 = _interopRequireDefault(_https);

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

var _util = require('util');

var _shimmer = require('shimmer');

var _shimmer2 = _interopRequireDefault(_shimmer);

var _performanceNode = require('performance-node');

var _performanceNode2 = _interopRequireDefault(_performanceNode);

var _v = require('uuid/v4');

var _v2 = _interopRequireDefault(_v);

var _lodash = require('lodash.pickby');

var _lodash2 = _interopRequireDefault(_lodash);

var _isarray = require('isarray');

var _isarray2 = _interopRequireDefault(_isarray);

var _flat = require('flat');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debug = (0, _util.debuglog)('@iopipe/trace');

/*eslint-disable babel/no-invalid-this*/

function unwrap() {
  [_http2.default, _https2.default].forEach(function (mod) {
    ['get', 'request'].forEach(function (method) {
      if (mod[method].__wrapped) {
        _shimmer2.default.unwrap(mod, method);
      }
    });
    delete mod.__iopipeShimmer;
  });
}

function wrapHttpGet(mod) {
  return function (options, cb) {
    var req = mod.request(options, cb);
    req.end();
    return req;
  };
}

// these are keys that are mostly node specific and come from the actual js request object
var unnecessaryReqKeys = new Map(['accept-encoding', 'agent', 'automaticFailover', 'cache', 'decompress', 'followRedirect', 'host', 'href', 'retries',
// 'slashes',
'search', 'strictTtl', 'throwHttpErrors', 'useElectronNet', 'user-agent'].map(function (s) {
  return [s];
}));

function excludeUnnecessaryReqKeys(obj) {
  return (0, _lodash2.default)(obj, function (v, k) {
    return !unnecessaryReqKeys.has(k);
  });
}

function getReqDataObject(rawOptions, protocol) {
  var reqDataObj = Object.assign({}, rawOptions);
  // some libraries (superagent) do not pass protocol and pathname, which is problematic when trying to use url.format - set sensible defaults
  reqDataObj.protocol = reqDataObj.protocol || protocol;
  reqDataObj.pathname = reqDataObj.pathname || reqDataObj.path;

  var href = typeof rawOptions === 'string' ? rawOptions : _url2.default.format(reqDataObj);
  var originalObj = typeof rawOptions === 'string' ? { href: rawOptions } : rawOptions;

  var data = Object.assign({}, originalObj, _url2.default.parse(href));

  // ensure url key is present with original URI, it can be slightly transformed by url.format
  data.url = href;

  // simple rename
  data.query = data.search;

  // sometimes request headers come in as an array
  // record each header value individually as a new custom metric
  Object.keys(data.headers || {}).forEach(function (k) {
    if ((0, _isarray2.default)(data.headers[k])) {
      data.headers[k].forEach(function (innerHeaderValue, index) {
        data.headers[`${k}.${index}`] = innerHeaderValue;
      });
    }
  });

  // delete duplicate or extraneous keys
  return excludeUnnecessaryReqKeys(data);
}

var initialResKeys = new Map(['headers', 'statusCode', 'statusMessage'].map(function (s) {
  return [s];
}));

function getResDataObject(res) {
  return (0, _lodash2.default)(res, function (v, k) {
    return initialResKeys.has(k);
  });
}

var defaultKeysToRecord = new Map(['request.hash', 'request.headers.accept-encoding', 'request.headers.user-agent', 'request.hostname', 'request.method', 'request.path', 'request.pathname', 'request.port', 'request.protocol', 'request.query', 'request.url', 'response.headers.age', 'response.headers.cache-control', 'response.headers.connection', 'response.headers.content-encoding', 'response.headers.content-length', 'response.headers.content-type', 'response.headers.date', 'response.headers.etag', 'response.headers.server', 'response.headers.strict-transport-security', 'response.headers.vary', 'response.statusCode', 'response.statusMessage'].map(function (s) {
  return [s];
}));

function filterData() {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var completeHttpObj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var whitelistedObject = (0, _lodash2.default)(completeHttpObj, function (v, k) {
    return defaultKeysToRecord.has(k);
  });
  if (typeof config.filter === 'function') {
    return config.filter(whitelistedObject, completeHttpObj);
  }
  return whitelistedObject;
}

function wrapHttpRequest(_ref) {
  var timeline = _ref.timeline,
      _ref$data = _ref.data,
      moduleData = _ref$data === undefined ? {} : _ref$data,
      _ref$config = _ref.config,
      config = _ref$config === undefined ? {} : _ref$config,
      protocol = _ref.protocol;

  return function (original) {
    return function (rawOptions, originalCallback) {
      // bail if we have already started tracking this request
      // this can happen by calling https.request(opts)
      // which ends up calling http.request(opts)
      if (originalCallback && originalCallback.__iopipeTraceId) {
        return original.apply(this, [rawOptions, originalCallback]);
      }

      // id of this particular trace
      var id = (0, _v2.default)();
      // start the trace
      timeline.mark(`start:${id}`);

      // setup http trace data that will be sent to IOpipe later
      moduleData[id] = {};
      moduleData[id].request = getReqDataObject(rawOptions, protocol);

      // the func to execute at the end of the http call
      function extendedCallback(res) {
        timeline.mark(`end:${id}`);
        // add full response data
        moduleData[id].response = getResDataObject(res);
        // flatten object for easy transformation/filtering later
        moduleData[id] = (0, _flat.flatten)(moduleData[id], { maxDepth: 5 });
        moduleData[id] = filterData(config, moduleData[id]);

        // if filter function returns falsey value, drop all data completely
        if (typeof moduleData[id] !== 'object') {
          timeline.data = timeline.data.filter(function (d) {
            return !new RegExp(id).test(d.name);
          });
          delete moduleData[id];
        }

        if (typeof originalCallback === 'function') {
          return originalCallback.apply(this, [res]);
        }
        return true;
      }

      // add traceId to callback so we do not create duplicate data from inner http calls
      // this can happen for the https module which calls the http module internally
      extendedCallback.__iopipeTraceId = id;

      return original.apply(this, [rawOptions, extendedCallback]);
    };
  };
}

function wrap() {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      timeline = _ref2.timeline,
      _ref2$data = _ref2.data,
      data = _ref2$data === undefined ? {} : _ref2$data,
      _ref2$config = _ref2.config,
      config = _ref2$config === undefined ? {} : _ref2$config;

  if (!(timeline instanceof _performanceNode2.default)) {
    debug('Timeline passed to shimmerHttp.wrap not an instance of performance-node. Skipping.');
    return false;
  }

  if (!_http2.default.__iopipeShimmer) {
    _shimmer2.default.wrap(_http2.default, 'get', function () {
      return wrapHttpGet(_http2.default);
    });
    _shimmer2.default.wrap(_http2.default, 'request', wrapHttpRequest({ timeline, data, config, protocol: 'http' }));
    _http2.default.__iopipeShimmer = true;
  }

  if (!_https2.default.__iopipeShimmer) {
    _shimmer2.default.wrap(_https2.default, 'get', function () {
      return wrapHttpGet(_https2.default);
    });
    _shimmer2.default.wrap(_https2.default, 'request', wrapHttpRequest({ timeline, data, config, protocol: 'https' }));
    _https2.default.__iopipeShimmer = true;
  }

  return true;
}

exports.unwrap = unwrap;
exports.wrap = wrap;